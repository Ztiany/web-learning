/*
具体参考：<https://wangdoc.com/javascript/types/object>

==========================================================
                        对象
==========================================================

对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。

    1. 对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。
    2. 如果键名是数值，会被自动转为字符串。如果键名不符合标识名的条件（比如第一个字符为数字，或者
       含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。
    3. 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为
       函数，通常把这个属性称为“方法”，它可以像函数那样调用。
*/
console.log("========== 对象 ==========")
let object1 = {
    a: 'a',
    b: 'b',
    c: 'c',
}
console.log("object1:", object1)

/*
==========================================================
                        对象表达式
==========================================================

对象采用大括号表示，比如 `{ foo: 123 }`，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？
JavaScript 引擎读到上面这行代码，会发现可能有两种含义。

    - 第一种可能是，这是一个表达式，表示一个包含 foo 属性的对象；
    - 第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签 foo，指向表达式 123。

为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。
如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。
*/
console.log("========== 对象表达式 ==========")
{
    console.log(123)
} // 123

// 这里声明了一个对象，但是没有赋值，所以没有任何作用。
({foo: 123})

// 在 eval 语句（作用是对字符串求值）中，尤其要注意这种情况。
let eval1 = eval('{foo: 123}') // 123，eval 将其解析为代码块，在代码块中，foo 是一个标签，123 是表达式，因此最后的值是 123。
let eval2 = eval('({foo: 123})') // {foo: 123}，eval 将其解析为对象，所以返回对象。
console.log("eval1: ", eval1)
console.log("eval2: ", eval2)

/*
==========================================================
                        属性操作
==========================================================

读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。

需要注意的点：

    1. 如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。
    2. 方括号运算符内部还可以使用表达式。
    3. 方括号中，数字键可以不加引号，因为会自动转成字符串。
    4. 数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。
*/
console.log("========== 属性操作 ==========")

const strFoo = 'strBar';

const object3 = {
    strFoo: 1,
    strBar: 2
};

console.log("object3.strFoo: ", object3.strFoo); // 1
console.log("object3[strFoo]: ", object3[strFoo]/* 这里就是等于 object['strBar'] */); // 2

/*
==========================================================
                        属性的赋值
==========================================================

点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。
*/
console.log("========== 属性的赋值 ==========")
let object4 = {};

object4.foo = 'Hello';
console.log("object4.foo: ", object4.foo); // Hello
console.log("object4.non: ", object4.non); // undefined

/*
==========================================================
                    属性的查看: keys
==========================================================

查看一个对象本身的所有属性，可以使用 Object.keys 方法。该方法返回一个数组，
成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
*/
console.log("========== 属性的查看: keys ==========")
console.log("Object.keys(object4): ", Object.keys(object4));

/*
==========================================================
                    属性的删除：delete
==========================================================

delete 命令用于删除对象的属性，删除成功后返回 true。注意：

    1. 删除一个不存在的属性，delete 不报错，而且返回 true。
    2. 只有一种情况，delete 命令会返回 false，那就是该属性存在，且不得删除。
       即该属性的原属性 configurable 为 false。具体参考 Object.defineProperty 方法
    3. delete 命令只能删除对象本身的属性，无法删除继承的属性。
*/
console.log("========== 属性的删除：delete ==========")

let object5 = {};
Object.defineProperty(object5, 'p', {
    value: 123,
    configurable: false
});
Object.defineProperty(object5, 'q', {
    value: 123,
    configurable: true,
    enumerable: true
});
console.log("object5: ", object5)

/*
==========================================================
                    属性是否存在：in 运算符
==========================================================

in 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），
如果包含就返回 true，否则返回 false。它的左边是一个字符串，表示属性
名，右边是一个对象。

in 运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。
比如对象 obj 本身并没有 toString 属性，但是 in 运算符会返回 true，
因为这个属性是继承的。这时，可以使用对象的 hasOwnProperty 方法判断一下。
*/
console.log("========== 属性是否存在：in 运算符 ==========")
if ('toString' in object5) {
    console.log("object5.hasOwnProperty('toString'): ", object5.hasOwnProperty('toString')) // false
}

/*
==========================================================
                    属性的遍历：for...in 循环
==========================================================

for...in 循环用来遍历一个对象的全部属性。

    1. 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
    2. 它不仅遍历对象自身的属性，还遍历继承的属性。

*/
console.log("==========  属性的遍历：for...in 循环 ==========")
for (const key in object5) {
    if (object5.hasOwnProperty(key)) {
        console.log("object has its own property: ", key);
    } else {
        console.log("object has inherited property: ", key);
    }
}

/*
==========================================================
                    with 语句
==========================================================

with 的作用是操作同一个对象的多个属性时，提供一些书写的方便。

特别注意：如果 with 区块内部有变量的赋值操作，必须是当前对象已经存在的属性，
否则会创造一个当前作用域的全局变量。
*/
console.log("==========  with 语句 ==========")

let object6 = {
    a: "a",
    b: "b"
}

with (object6) {
    a = 4;
    b = 5;
    c = 6; // c 没有定义在 object6 中，所以会创建一个全局变量 c。
}

console.log("object6: ", object6);
console.log("c: ", c);
